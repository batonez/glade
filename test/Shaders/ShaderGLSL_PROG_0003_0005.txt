
//== PROGRAM LINK STATUS = TRUE
//== PROGRAM VALIDATE STATUS = TRUE
/*== INFO LOG ==
Vertex shader(s) linked, fragment shader(s) linked.
  == INFO LOG END ==*/

//======================================================
//   Vertex Shader 1 
//======================================================

//== SHADER COMPILE STATUS = TRUE
/*== INFO LOG ==
Vertex shader was successfully compiled to run on hardware.
 WARNING: 0:69: warning(#402) Implicit truncation of vector from size 4 to size 2.   == INFO LOG END ==*/
const float ZERO = 0.0, ONE = 1.0;

uniform mat4 uProjectionMatrix;
uniform mat4 uWorldViewMatrix;

uniform float uTexCoordScaleX0;
uniform float uTexCoordScaleY0;
uniform float uTexCoordOffsetX0;
uniform float uTexCoordOffsetY0;

uniform int     uLight;
uniform vec3    uLightDirection;
uniform vec3    uLightHalfplane;
uniform vec4    uLightAmbient;
uniform vec4    uLightDiffuse;
uniform vec4    uLightSpecular;
uniform vec4    uMaterialAmbient;
uniform vec4    uMaterialDiffuse;
uniform vec4    uMaterialSpecular;
uniform float   uMaterialShininess;

attribute vec4  aPosition;
attribute vec3  aNormal;
attribute vec2  aTexCoord0;

varying vec2    vTexCoord0;
varying vec4    vColor;

vec4 calculateLight(vec3 normal) {
   vec4 computedColor = vec4(ZERO, ZERO, ZERO, ZERO);
   float ndotl;
   float ndoth;
   ndotl = max(ZERO, dot(normal, uLightDirection));
   ndoth = max(ZERO, dot(normal, uLightHalfplane));
   computedColor += (uLightAmbient * uMaterialAmbient);
   computedColor += (ndotl * uLightDiffuse * uMaterialDiffuse);
   
   if (ndoth > ZERO) {
      computedColor += (pow(ndoth, uMaterialShininess) *
      uMaterialSpecular *
      uLightSpecular);
   }
   
   return computedColor;
}

vec4 transformTexCoords(vec2 texCoord, vec2 offset, vec2 scale) {
   vec4 result;
   result.y = 0;
   result.z = 0;
   
   if (scale.x < ZERO) {
      result.x = ONE + texCoord.x * scale.x - offset.x;
   } else {
      result.x = texCoord.x * scale.x + offset.x;
   }
      
   if (scale.y < ZERO) {
      result.y = ONE + texCoord.y * scale.y - offset.y;
   } else {
      result.y = texCoord.y * scale.y + offset.y;
   }
      
   return result;
}

void main() {
  gl_Position = uProjectionMatrix * uWorldViewMatrix * aPosition;
  vTexCoord0 = transformTexCoords(aTexCoord0, vec2(uTexCoordOffsetX0, uTexCoordOffsetY0), vec2(uTexCoordScaleX0, uTexCoordScaleY0));
  
  if (uLight != ZERO) {
     vec4 rotatedNormal = normalize(uWorldViewMatrix * vec4(aNormal.xyz, ZERO));
     vColor = calculateLight(rotatedNormal.xyz);
  } else {
     vColor = vec4(ZERO, ZERO, ZERO, ZERO);
  }
};

//======================================================
//   Fragment Shader 2
//======================================================

//== SHADER COMPILE STATUS = TRUE
/*== INFO LOG ==
Fragment shader was successfully compiled to run on hardware.
  == INFO LOG END ==*/
uniform sampler2D uTextureSampler0;
uniform vec4 uColor;
uniform int uReplaceColor = 0;

varying vec4 vColor;
varying vec2 vTexCoord0;

vec4 blendColors(vec4 baseColor, vec4 overlayColor) {
   return vec4(
      baseColor.r * (1.0 - overlayColor.a) + overlayColor.r * overlayColor.a, 
      baseColor.g * (1.0 - overlayColor.a) + overlayColor.g * overlayColor.a, 
      baseColor.b * (1.0 - overlayColor.a) + overlayColor.b * overlayColor.a, 
      baseColor.a * (1.0 - overlayColor.a) + overlayColor.a * overlayColor.a);
}

void main(void)
{
  vec4 texColor = texture2D(uTextureSampler0, vTexCoord0);
  gl_FragColor = texColor;
  gl_FragColor = blendColors(gl_FragColor, uColor);
};
